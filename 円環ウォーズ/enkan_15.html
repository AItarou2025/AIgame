<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>円環バトル — Endless Arena Shooter</title>
<style>
  html,body{height:100%;margin:0;background:#0b1020;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;}
  #game {display:block;margin:0 auto;background:#061022;touch-action:none;}
  .ui {
    position:absolute; left:16px; top:16px;
    font-size:14px; line-height:1.6;
    background:rgba(0,0,0,0.25);
    padding:8px 12px; border-radius:8px;
    backdrop-filter:blur(4px);
    display:none;
  }
  footer {position:fixed;left:0;right:0;bottom:8px;text-align:center;font-size:12px;color:#9db0ff;opacity:0.7}
</style>
</head>
<body>
<canvas id="game"></canvas>
<div class="ui" id="hud">Score: 0<br>Lives: 3<br>Time: ∞</div>
<footer>円環バトル — エンドレスモード</footer>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', {alpha:false});
  const hud = document.getElementById('hud');
  let W = canvas.width = window.innerWidth;
  let H = canvas.height = window.innerHeight;

  // === 基本設定 ===
  const ENEMY_SPEED_BASE = 0.07;
  const PLAYER_RADIUS = 18;
  const BULLET_SPEED = 0.5; // 弾の速度を下げる
  const FIRE_COOLDOWN = 180;
  const PARTICLE_COUNT = 12;

  // === 状態 ===
  let gameState = "title"; 
  let lastTime = performance.now();
  let mouse = {x: W/2, y: H/2};
  let player = {x: W/2, y: H/2, angle: 0};
  let bullets = [], enemies = [], particles = [];
  let specialEnemies = []; // 白い三角形特殊敵
  let score = 0, lives = 3, elapsed = 0;
  let spawnTimer = 0, fireTimer = 0, roundStart = 0;
  let gameResult = "";
  let countdown = 3;
  let countdownStart = 0;

  function rand(min,max){return Math.random()*(max-min)+min;}
  function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}

  function resize(){
    W = canvas.width = window.innerWidth;
    H = canvas.height = window.innerHeight;
    player.x = W/2; player.y = H/2;
  }
  window.addEventListener('resize',resize);

  // === 入力 ===
  canvas.addEventListener('mousemove',(e)=>{
    const r = canvas.getBoundingClientRect();
    mouse.x = (e.clientX - r.left) * (canvas.width / r.width);
    mouse.y = (e.clientY - r.top) * (canvas.height / r.height);
  });
  canvas.addEventListener('click',()=>{ if(gameState==="title") startCountdown(); });
  window.addEventListener('keydown',(e)=>{
    if(e.code==="Space" && gameState==="title") startCountdown();
    if(e.code==="KeyR" && gameState==="gameover") gameState="title";
  });

  function startCountdown(){
    countdown = 3;
    countdownStart = performance.now();
    gameState = "countdown";
    hud.style.display="none";
    requestAnimationFrame(countdownLoop);
  }

  function countdownLoop(now){
    const elapsedSec = Math.floor((now - countdownStart) / 1000);
    const remain = 3 - elapsedSec;
    drawTitle(remain > 0 ? remain : "START!");
    if(remain <= 0){
      if(now - countdownStart > 4000){
        startGame();
        return;
      }
    }
    if(gameState==="countdown") requestAnimationFrame(countdownLoop);
  }

  function startGame(){
    score=0; lives=3; elapsed=0;
    bullets=[]; enemies=[]; particles=[]; specialEnemies=[];
    spawnTimer=0; fireTimer=0;
    roundStart=performance.now();
    gameState="playing";
    hud.style.display="block";
    requestAnimationFrame(loop);
  }

  // ============================================================
  // 敵生成（ボスなし）
  // ============================================================
  function spawnEnemy(){
    const ringR = Math.min(W,H)*0.48;
    let type = "red";

    if(elapsed >= 90 && Math.random() < 0.15) type = "purple";
    else if(Math.random() < 0.1) type = "blue";

    let enemy = null;
    for(let attempt=0; attempt<10; attempt++){
      const ang = rand(0, Math.PI*2);
      const x = player.x + Math.cos(ang)*ringR;
      const y = player.y + Math.sin(ang)*ringR;

      let temp;
      if(type==="red")
        temp = {x,y,speed:ENEMY_SPEED_BASE+rand(-0.02,0.02),r:34,hp:2,type:"red"}; // 赤体力2
      else if(type==="blue")
        temp = {x,y,speed:(ENEMY_SPEED_BASE*1.3)+rand(-0.02,0.02),r:22,hp:4,type:"blue"}; // 青体力4
      else
        temp = {x,y,speed:(ENEMY_SPEED_BASE*0.9)+rand(-0.01,0.01),r:28,hp:2,type:"purple"};

      let ok = true;
      for(const e of enemies){
        if(dist(e,temp) < e.r + temp.r + 10){
          ok = false; break;
        }
      }

      if(ok){ enemy = temp; break; }
    }

    if(enemy) enemies.push(enemy);
  }

  function shoot(angle){
    const now=performance.now();
    if(now-fireTimer<FIRE_COOLDOWN)return;
    fireTimer=now;
    bullets.push({
      x:player.x+Math.cos(angle)*(PLAYER_RADIUS+6),
      y:player.y+Math.sin(angle)*(PLAYER_RADIUS+6),
      dx:Math.cos(angle)*BULLET_SPEED,
      dy:Math.sin(angle)*BULLET_SPEED,
      life:2000
    });
  }

  function spawnParticles(x,y,base,str,color="#ffd875"){
    for(let i=0;i<PARTICLE_COUNT;i++){
      const a=base+rand(-1,1);
      particles.push({
        x,y,dx:Math.cos(a)*rand(0.05,0.7)*str,
        dy:Math.sin(a)*rand(0.05,0.7)*str,
        life:rand(300,900),size:rand(1,4),color
      });
    }
  }

  // ============================================================
  // 特殊敵生成
  // ============================================================
  function spawnSpecialEnemy(){
    const x = rand(50, W-50);
    const y = rand(50, H-50);
    const angle = rand(0, Math.PI*2);
    const speed = rand(0.05, 0.15);
    specialEnemies.push({
      x, y,
      dx: Math.cos(angle)*speed,
      dy: Math.sin(angle)*speed,
      hp: 5,
      lifeTime: 10000,
      spawnTime: performance.now()
    });
  }

  function updateSpecialEnemies(dt){
    const now = performance.now();
    for(let i=specialEnemies.length-1; i>=0; i--){
      const e = specialEnemies[i];
      e.x += e.dx*dt;
      e.y += e.dy*dt;
      if(e.x<20 || e.x>W-20) e.dx*=-1;
      if(e.y<20 || e.y>H-20) e.dy*=-1;
      if(now - e.spawnTime > e.lifeTime){
        specialEnemies.splice(i,1);
        continue;
      }
      bullets.forEach((b,j)=>{
        if(dist(b,e)<8){
          bullets.splice(j,1);
          e.hp--;
          spawnParticles(b.x,b.y,0,1,"#ffffff");
          if(e.hp<=0){
            specialEnemies.splice(i,1);
            bullets.forEach(bb=>{
              bb.dx *= 1.2;
              bb.dy *= 1.2;
            });
          }
        }
      });
    }
  }

  function drawSpecialEnemies(){
    specialEnemies.forEach(e=>{
      ctx.save();
      ctx.translate(e.x,e.y);
      ctx.fillStyle="#ffffff";
      ctx.beginPath();
      ctx.moveTo(0,-10);
      ctx.lineTo(7,10);
      ctx.lineTo(-7,10);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    });
  }

  // ============================================================
  // メインループ
  // ============================================================
  function loop(now){
    const dt=Math.min(40,now-lastTime); lastTime=now;
    if(gameState!=="playing") return;
    elapsed=(now-roundStart)/1000;
    player.angle=Math.atan2(mouse.y-player.y,mouse.x-player.x);
    shoot(player.angle);

    spawnTimer+=dt;
    const spawnInterval = 1000;
    if(spawnTimer > spawnInterval){
      spawnTimer=0;
      let spawnCount = 1;
      if(elapsed >= 60 && Math.random() < 0.5) spawnCount++;
      for(let i=0; i<spawnCount; i++) spawnEnemy();
    }

    // 特殊敵生成例：30秒以降低確率で出現
    if(elapsed > 30 && Math.random() < 0.002) spawnSpecialEnemy();

    const speedMultiplier = 1 + Math.floor(elapsed / 30) * 0.05;

    bullets.forEach((b,i)=>{
      b.x+=b.dx*dt; b.y+=b.dy*dt; b.life-=dt;
      if(b.life<=0) bullets.splice(i,1);
    });

    enemies.forEach((e,i)=>{
      const ang=Math.atan2(player.y-e.y,player.x-e.x);
      e.x+=Math.cos(ang)*e.speed*speedMultiplier*dt;
      e.y+=Math.sin(ang)*e.speed*speedMultiplier*dt;

      if(dist(e,player)<PLAYER_RADIUS+e.r){
        spawnParticles(e.x,e.y,ang+Math.PI,1.5);
        enemies.splice(i,1); lives--;
        if(lives<=0){gameState="gameover"; gameResult="Game Over";}
      }

      bullets.forEach((b,j)=>{
        if(dist(b,e)<e.r+4){
          bullets.splice(j,1);
          e.hp--;
          const col = e.type==="blue" ? "#80ffff" :
                      e.type==="purple" ? "#c380ff" : "#ffd875";
          spawnParticles(b.x,b.y,ang,1,col);
          if(e.hp<=0){
            score += e.type==="purple" ? 3 : (e.type==="blue" ? 2 : 1);
            enemies.splice(i,1);
          }
        }
      });
    });

    updateSpecialEnemies(dt);

    particles.forEach((p,i)=>{
      p.x+=p.dx*dt; p.y+=p.dy*dt; p.life-=dt;
      if(p.life<=0) particles.splice(i,1);
    });

    draw();
    drawSpecialEnemies();

    hud.innerHTML=`撃破数: ${score}<br>残機: ${lives}<br>経過時間: ${Math.floor(elapsed)}秒`;
    if(gameState==="playing") requestAnimationFrame(loop);
    else drawGameOver();
  }

  // ============================================================
  // 描画
  // ============================================================
  function draw(){
    ctx.fillStyle="#061022"; ctx.fillRect(0,0,W,H);

    const ringR=Math.min(W,H)*0.48;
    ctx.save(); ctx.translate(player.x,player.y);
    ctx.beginPath(); ctx.arc(0,0,ringR,0,Math.PI*2);
    ctx.lineWidth=3; ctx.strokeStyle="rgba(80,120,255,0.06)"; ctx.stroke();
    ctx.restore();

    ctx.fillStyle="#ffd875";
    bullets.forEach(b=>{ctx.beginPath();ctx.arc(b.x,b.y,4,0,Math.PI*2);ctx.fill();});

    enemies.forEach(e=>{
      ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2);
      if(e.type==="blue") ctx.fillStyle="#4af5ff";
      else if(e.type==="purple") ctx.fillStyle="#a060ff";
      else ctx.fillStyle="#ff6b6b";
      ctx.fill();
      if(e.type==="blue" || e.type==="purple"){
        ctx.strokeStyle="#ffffff"; ctx.lineWidth=2; ctx.stroke();
      }
    });

    ctx.save(); ctx.translate(player.x,player.y); ctx.rotate(player.angle);
    ctx.beginPath(); ctx.arc(0,0,PLAYER_RADIUS,0,Math.PI*2);
    ctx.fillStyle="#6ea8ff"; ctx.fill();
    ctx.fillStyle="#e6f0ff"; ctx.fillRect(0,-6,PLAYER_RADIUS+20,12);
    ctx.restore();

    particles.forEach(p=>{
      ctx.globalAlpha=Math.max(0, Math.min(1,p.life/900));
      ctx.beginPath();ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
      ctx.fillStyle=p.color;ctx.fill();ctx.globalAlpha=1;
    });
  }

  function drawGameOver(){
    hud.style.display="none";
    ctx.fillStyle="rgba(0,0,0,0.7)";
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle="#fff"; ctx.textAlign="center";
    ctx.font="bold 40px system-ui"; ctx.fillText(gameResult,W/2,H/2-40);
    ctx.font="24px system-ui"; ctx.fillText(`撃破数: ${score}`,W/2,H/2);
    ctx.font="16px system-ui"; ctx.fillText("Press R to return to Title",W/2,H/2+36);
  }

  function drawTitle(text="円環バトル"){
    ctx.fillStyle="#061022"; ctx.fillRect(0,0,W,H);
    ctx.textAlign="center"; ctx.fillStyle="#fff";
    ctx.font="bold 60px system-ui"; ctx.fillText("円環バトル",W/2,H/2-40);
    ctx.font="24px system-ui"; ctx.fillText("Endless Arena Shooter",W/2,H/2);
    ctx.font="32px system-ui"; 
    if(text!=="円環バトル") ctx.fillText(text,W/2,H/2+60);
    else ctx.fillText("クリックまたはスペースキーで開始",W/2,H/2+60);
  }

  function titleLoop(){
    drawTitle();
    if(gameState==="title") requestAnimationFrame(titleLoop);
  }

  resize();
  titleLoop();
})();
</script>
</body>
</html>
