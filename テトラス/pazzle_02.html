<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>テトリス風ブロックパズル</title>
<style>
  body {
    background: #111;
    color: #fff;
    font-family: sans-serif;
    text-align: center;
  }
  canvas {
    background: #000;
    display: block;
    margin: 20px auto;
    border: 2px solid #555;
  }
</style>
</head>
<body>

<h1>テトリス風ブロックパズル</h1>
<p>← → 移動 / ↑ 回転 / ↓ 落下</p>
<canvas id="game" width="300" height="600"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const COLS = 10;
const ROWS = 20;
const BLOCK = 30;

const field = Array.from({ length: ROWS }, () =>
  Array(COLS).fill(0)
);

const COLORS = [
  null,
  "#00ffff", // I
  "#0000ff", // J
  "#ff7f00", // L
  "#ffff00", // O
  "#00ff00", // S
  "#800080", // T
  "#ff0000"  // Z
];

const SHAPES = [
  [],
  [[1,1,1,1]],
  [[1,0,0],[1,1,1]],
  [[0,0,1],[1,1,1]],
  [[1,1],[1,1]],
  [[0,1,1],[1,1,0]],
  [[0,1,0],[1,1,1]],
  [[1,1,0],[0,1,1]]
];

let current = createPiece();
let dropCounter = 0;
let dropInterval = 500;
let lastTime = 0;

function createPiece() {
  const type = Math.floor(Math.random() * 7) + 1;
  return {
    shape: SHAPES[type],
    color: type,
    x: Math.floor(COLS / 2) - 1,
    y: 0
  };
}

function drawBlock(x, y, color) {
  ctx.fillStyle = COLORS[color];
  ctx.fillRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
  ctx.strokeStyle = "#111";
  ctx.strokeRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  field.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) drawBlock(x, y, value);
    });
  });

  current.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        drawBlock(current.x + x, current.y + y, current.color);
      }
    });
  });
}

function collide(piece) {
  return piece.shape.some((row, y) =>
    row.some((value, x) => {
      if (!value) return false;
      const nx = piece.x + x;
      const ny = piece.y + y;
      return (
        nx < 0 ||
        nx >= COLS ||
        ny >= ROWS ||
        (ny >= 0 && field[ny][nx])
      );
    })
  );
}

function merge() {
  current.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        field[current.y + y][current.x + x] = current.color;
      }
    });
  });
}

function clearLines() {
  for (let y = ROWS - 1; y >= 0; y--) {
    if (field[y].every(v => v !== 0)) {
      field.splice(y, 1);
      field.unshift(Array(COLS).fill(0));
      y++;
    }
  }
}

function rotate() {
  const rotated = current.shape[0].map((_, i) =>
    current.shape.map(row => row[i]).reverse()
  );
  const backup = current.shape;
  current.shape = rotated;
  if (collide(current)) current.shape = backup;
}

function drop() {
  current.y++;
  if (collide(current)) {
    current.y--;
    merge();
    clearLines();
    current = createPiece();
    if (collide(current)) {
      alert("ゲームオーバー！");
      field.forEach(row => row.fill(0));
    }
  }
  dropCounter = 0;
}

document.addEventListener("keydown", e => {
  if (e.key === "ArrowLeft") {
    current.x--;
    if (collide(current)) current.x++;
  }
  if (e.key === "ArrowRight") {
    current.x++;
    if (collide(current)) current.x--;
  }
  if (e.key === "ArrowDown") {
    drop();
  }
  if (e.key === "ArrowUp") {
    rotate();
  }
});

function update(time = 0) {
  const delta = time - lastTime;
  lastTime = time;
  dropCounter += delta;
  if (dropCounter > dropInterval) drop();
  draw();
  requestAnimationFrame(update);
}

update();
</script>

</body>
</html>


